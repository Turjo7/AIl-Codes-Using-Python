# -*- coding: utf-8 -*-
"""011152200_KNN_Classification.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1EvULOEYBhSQ6ghkgPo_mjJcQpxHhnVfn
"""

from google.colab import drive
drive.mount('/content/gdrive')

from numpy import genfromtxt
def load_dataset(path):
  return genfromtxt(path, delimiter=',')

regre = '/content/gdrive/MyDrive/AI/KNN/iris.csv'

dataset = load_dataset(regre)

#my_data.shape
type(my_data)

data = my_data.tolist()
for i in range(5):
  print(data[i])
type(data)

import random
iris = dataset.tolist()
# print(iris)
# print()
random.shuffle(iris)
#print(iris)

from random import random
#print(random())

Train_set=[]
Val_set=[]
Test_set=[]


for x in iris:
  R = random()
  if R >= 0 and R <= 0.7:
    Train_set.append(x)
  elif R >= 0.7 and R <= 0.85:
    Val_set.append(x)
  else:
    Test_set.append(x)

print(len(Train_set))
print(len(Val_set))
print(len(Test_set))

from scipy.spatial import distance
import operator
k = 10
#print(distance.euclidean([1,0,0], [0,1,0]))
L = {}
correct = 0
for s in Val_set:
  major_class = {}
  L = {}
  for v in Train_set:
    #ed = distance.euclidean(s[1:], v[1:])
    ed = distance.euclidean(s[0:(len(s)-1)], v[0:(len(v)-1)])
    L[ed] = v
  sorted_L = sorted(L.keys())
  count = 1
  major_class = {}
  for x in sorted_L:
    if int(L[x][-1]) in major_class.keys(): 
      major_class[int(L[x][-1])] = major_class[int(L[x][-1])]+1
    else:
      major_class[int(L[x][-1])] = 0
      major_class[int(L[x][-1])] = major_class[int(L[x][-1])]+1
    count = count + 1
    if(count > k):
      break
  #print(major_class)
  val = max(major_class.items(), key=operator.itemgetter(1))[0]
  # print(f"S_value = {int(s[-1])}")
  # print(f"V_value = {val}")
  if(int(s[-1]) == val):
    correct = correct + 1
#print(correct)
accuracy = (correct/len(Val_set))*100
print(accuracy)

#print(distance.euclidean([1,0,0], [0,1,0]))
L = {}
correct = 0
for s in Test_set:
  major_class = {}
  L = {}
  for v in Train_set:
    #ed = distance.euclidean(s[1:], v[1:])
    ed = distance.euclidean(s[0:(len(s)-1)], v[0:(len(v)-1)])
    L[ed] = v
  sorted_L = sorted(L.keys())
  count = 1
  major_class = {}
  for x in sorted_L:
    if int(L[x][-1]) in major_class.keys(): 
      major_class[int(L[x][-1])] = major_class[int(L[x][-1])]+1
    else:
      major_class[int(L[x][-1])] = 0
      major_class[int(L[x][-1])] = major_class[int(L[x][-1])]+1
    count = count + 1
    if(count > k):
      break
  #print(major_class)
  val = max(major_class.items(), key=operator.itemgetter(1))[0]
  # print(f"S_value = {int(s[-1])}")
  # print(f"V_value = {val}")
  if(int(s[-1]) == val):
    correct = correct + 1
#print(correct)
accuracy = (correct/len(Test_set))*100
print(accuracy)