# -*- coding: utf-8 -*-
"""011152200_KNN_Regression.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1jszwBemJAgudIbXnHznJmHQHyIp0ca2c
"""

from google.colab import drive
drive.mount('/content/gdrive')

from numpy import genfromtxt
def load_dataset(path):
  return genfromtxt(path, delimiter=',')

regre = '/content/gdrive/MyDrive/AI/KNN/diabetes.csv'
dataset = load_dataset(regre)

import random
import math
iris = dataset.tolist()
for x in iris:
  for y in range(len(x)):
    z = float(x[y])
    if math.isnan(z):
      x[y] = 0
# print(iris)
# print()
random.shuffle(iris)
print(iris)

from random import random
#print(random())

Train_set=[]
Val_set=[]
Test_set=[]


for x in iris:
  R = random()
  if R >= 0 and R <= 0.7:
    Train_set.append(x)
  elif R >= 0.7 and R <= 0.85:
    Val_set.append(x)
  else:
    Test_set.append(x)

print(len(Train_set))
print(len(Val_set))
print(len(Test_set))

from scipy.spatial import distance
import operator
k = 10
#print(distance.euclidean([1,0,0], [0,1,0]))
L = {}
correct = 0
error = 0
for s in Val_set:
  major_class = {}
  L = {}
  for v in Train_set:
    ed = distance.euclidean(s[0:(len(s)-1)], v[0:(len(v)-1)])
    L[ed] = v[-1]
  sorted_L = sorted(L.keys())

  # print(type(sorted_L))
  count = 1
  total_val = 0.0
  for x in sorted_L:
    total_val = total_val + L[x]
    count = count + 1
    if(count > k):
      break
  val = total_val/k
  #print(f"True vale: {s[-1]}   Estimated val: {val}")
  #print(f'Error {s[-1] - val}')
  error = error + (s[-1] - val)**2
  # print(f"S_value = {int(s[-1])}")
  # print(f"V_value = {val}")
  if(int(s[-1]) == val):
    correct = correct + 1
#print(correct)
#print(error)
error_r = (error/len(Val_set))**(1/2)
print(error_r)

#print(distance.euclidean([1,0,0], [0,1,0]))
L = {}
correct = 0
for s in Test_set:
  major_class = {}
  L = {}
  for v in Train_set:
    ed = distance.euclidean(s[0:(len(s)-1)], v[0:(len(v)-1)])
    L[ed] = v[-1]
  sorted_L = sorted(L.keys())
  count = 1
  total_val = 0.0
  for x in sorted_L:
    total_val = total_val + L[x]
    count = count + 1
    if(count > k):
      break
  val = total_val/k
  #print(f"True vale: {s[-1]}   Estimated val: {val}")
  #print(f'Error {s[-1] - val}')
  error = error + (s[-1] - val)**2
  # print(f"S_value = {int(s[-1])}")
  # print(f"V_value = {val}")
  if(int(s[-1]) == val):
    correct = correct + 1
#print(correct)
#print(error)
error_r = (error/len(Val_set))**(1/2)
print(error_r)